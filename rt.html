<!DOCTYPE html>
<html>
<head><title>Javascript RT</title></head>

<body>
<canvas id="framebuffer" width="800" height="600"></canvas>
<script type="text/javascript">
/* Javascript minimal ray tracing engine
 * Copyright (C) 2012 Salvatore Sanfilippo <antirez@gmail.com>
 *
 * This softare is released under the terms of the BSD two-clause license. */

var ctx;
var pixels;
var screen_width = 320;
var screen_height = 200;
var frame = 0;

function init() {
    ctx = document.getElementById('framebuffer').getContext('2d');
    pixels = ctx.createImageData(screen_width, screen_height);
    setInterval(draw, 1000 / 25);
};

function draw() {
    var start = new Date().getTime();
    computeScene();
    ctx.putImageData(pixels, 0, 0);
    console.debug("Frame "+frame+" ms: "+((new Date().getTime())-start));
    frame++;
};

function computeScene() {
    var scene = new Scene();

    var sphere1 = scene.addObject(new Obj("Sphere 1",new Sphere()));
    var sphere2 = scene.addObject(new Obj("Sphere 2",new Sphere()));
    var light1 = scene.addLight(new Obj("Light 1",new Light()));
    var light2 = scene.addLight(new Obj("Light 2",new Light()));
    var light3 = scene.addLight(new Obj("Light 3",new Light()));

    sphere1.o.center.x = Math.cos(frame/10);
    sphere1.o.center.z = Math.sin(frame/10);
    sphere1.o.radius = 0.5;
   
    sphere2.o.center.x = 0;
    sphere2.o.radius = 0.5;

    light1.o.center.set(4,-1,-2);
    light2.o.center.set(-1,-1,-2);
    light3.o.center.set(1,-6,-2);

    light1.color.r = .5;
    light1.color.g = .5;
    light1.color.b = .5;

    light2.color.r = .3;
    light2.color.g = .3;
    light2.color.b = .3;

    light3.color.r = .4;
    light3.color.g = .4;
    light3.color.b = .4;

    sphere1.color.r = 1;
    sphere1.color.g = .3;
    sphere1.color.b = .3;
    sphere1.specularity = .5;

    sphere2.color.r = .3;
    sphere2.color.g = 1;
    sphere2.color.b = .3;
    sphere2.specularity = .5;

    scene.traceScene();
}

// Vector implementation

function Vector(x,y,z) {
    if (arguments.length == 0) {
        x = y = z = 0;
    }
    this.x = x;
    this.y = y;
    this.z = z;

    // Set x, y, z
    this.set = function(x,y,z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    // Return true if the two vectors are equal
    this.equal = function(v2) {
        var v1 = this;
        return v1.x == v2.x && v1.y == v2.y && v1.z == v2.z;
    }

    // Vectors addition
    this.add = function(v2) {
        var v1 = this;
        return new Vector(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);
    }

    // Vectors subtraction
    this.sub = function(v2) {
        var v1 = this;
        return new Vector(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z);
    }

    // Vectors multiplication
    this.mul = function(v2) {
        var v1 = this;
        return new Vector(v1.x*v2.x, v1.y*v2.y, v1.z*v2.z);
    }

    // Vectors division
    this.div = function(v2) {
        var v1 = this;
        return new Vector(
            v1.x/ (v2.x == 0 ? 1 : v2.x),
            v1.y/ (v2.y == 0 ? 1 : v2.y),
            v1.z/ (v2.z == 0 ? 1 : v2.z));
    }

    // Vector magnitude
    this.magnitude = function() {
        return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);
    }

    // Vector dot (scalar) product
    this.dot = function(v2) {
        var v1 = this;
        return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
    }

    // Vector cross (vectorial) product
    this.cross = function(v2) {
        var v1 = this;
        return new Vector(
            (v1.y*v2.z)-(v1.z*v2.y),
            (v1.z*v2.x)-(v1.x*v2.z),
            (v1.x*v2.y)-(v1.y*v2.x));
    }
    
    // Vector normalization (modify the vector so that that it has
    // magnitude 1 but with the same orientation as the original vector).
    this.normalize = function() {
        var m = this.magnitude();

        if (m == 0) m = 1;
        this.x /= m;
        this.y /= m;
        this.z /= m;
        return this;
    }
}

// Ray implementation

function Ray() {
    this.origin = new Vector();
    this.direction = new Vector();
}

// Sphere implementation

function Sphere() {
    this.type = "sphere";
    this.center = new Vector();
    this.radius = 1.0;

    /* Normal on a point of the sphere, normalized.
       We don't use the Vector object for speed issues. */
    this.normalToPoint = function(x,y,z) {
        x -= this.center.x;
        y -= this.center.y;
        z -= this.center.z;
        /* we already know the magnitudo that is just the radius of the sphere
           so we can easily normalize the vector just dividing for it. */
        x /= this.radius;
        y /= this.radius;
        z /= this.radius;
        return {x: x, y: y, z: z};
    }

    /* Intersect a ray with this sphere. Returns an object
       with two fields: 'type' and 'dist'.

       Type can be:

       0: no intersection
       1: internal intersection (the ray origin is inside the sphere)
       2: external intersection (the ray origin is outside the sphere)

       The distance is simply the distance between the ray origin and
       the intersection point.

       NOTE: This function needs ray.direction to be normalized. */
    this.intersect = function(ray) {
        var x, y, z, distance = +Infinity;

        /* set x,y,z to the sphere center minus the ray origin. */
        x = this.center.x - ray.origin.x;
        y = this.center.y - ray.origin.y;
        z = this.center.z - ray.origin.z;
        /* compute x,y,z dot product with itself. */
        var xyz_dot = (x*x)+(y*y)+(z*z);
        /* compute dot product between x,y,z and ray direction. */
        var b = (x*ray.direction.x)+(y*ray.direction.y)+(z*ray.direction.z);

        /* We can now compute the discriminant and check for intersections. */
        var disc = b*b - xyz_dot + this.radius*this.radius;
        var type = 0;

        if (disc > 0) {
            var d = Math.sqrt(disc);
            var root1 = b-d;
            var root2 = b+d;

            if (root2 > 0) {
                if (root1 < 0) {
                    if (root2 < distance) { distance = root2; type = -1; }
                } else {
                    if (root1 < distance) { distance = root1; type = 1; }
                }
            }
        }
        return {type: type, dist: distance};
    }
}

// Light

function Light() {
    this.type = "light";
    this.center = new Vector();
}

// Generic scene object implementation

function Obj(name,o) {
    this.name = name;
    this.o = o;
    this.color = {r: 1, g: 1, b: 1};
    this.specularity = 0;
}

// Scene object

function Scene() {
    this.objects = [];
    this.lights = [];

    this.addObject = function(o) {
        this.objects.push(o);
        return o;
    }

    this.addLight = function(o) {
        this.lights.push(o);
        return o;
    }

    this.traceRay = function (ray) {
        var obj = null;
        var color = {r: 0, g: 0, b: 0}
        var distance = +Infinity;

        for (var j = 0; j < this.objects.length; j++) {
            var test_obj = this.objects[j];
            var res = test_obj.o.intersect(ray);
            if (res.type) {
                if (obj == null || res.dist < distance) {
                    obj = test_obj;
                    distance = res.dist;
                }
            }
        }
        /* Determine the color if we hit sometihng */
        if (obj) {
            /* We have the distance, so we can compute the intersection
               point simply as: origin + (direction * distance) */
            var x = ray.origin.x + ray.direction.x*distance;
                y = ray.origin.y + ray.direction.y*distance;
                z = ray.origin.z + ray.direction.z*distance;
            /* Now get the normal to the intersection point of the object */
            var normal = obj.o.normalToPoint(x,y,z);
            for (j = 0; j < this.lights.length; j++) {
                var light = this.lights[j];
                /* Compute the vector that looks from the intersection
                   point to the light. We do this simply subtracting the
                   intersection point from the light position. */
                var lx = light.o.center.x - x;
                var ly = light.o.center.y - y;
                var lz = light.o.center.z - z;
                /* Normalize */
                var len = Math.sqrt(lx*lx + ly*ly + lz*lz);
                if (len == 0) len = 1;
                lx /= len;
                ly /= len;
                lz /= len;
                /* Now the dot product between the normal and the point
                   towards the light is the cosine between the angle
                   formed by the vectors, that is, our brightness. */
                var cosine = normal.x*lx+normal.y*ly+normal.z*lz;
                if (cosine < 0) cosine = 0;
                /* Diffuse shading */
                color.r += cosine * obj.color.r * light.color.r;
                color.g += cosine * obj.color.g * light.color.g;
                color.b += cosine * obj.color.b * light.color.b;
                /* Phong shading */
                if (obj.specularity > 0) {
                    var vrx = lx - normal.x * cosine * 2,
                        vry = ly - normal.y * cosine * 2,
                        vrz = lz - normal.z * cosine * 2;
                    var cosSigma = (ray.direction.x*vrx)+
                                   (ray.direction.y*vry)+
                                   (ray.direction.z*vrz);
                    if (cosSigma > 0) {
                        var specularity = obj.specularity;
                        color.r += light.color.r * specularity * Math.pow(cosSigma,64);
                        color.g += light.color.g * specularity * Math.pow(cosSigma,64);
                        color.b += light.color.b * specularity * Math.pow(cosSigma,64);
                    }
                }
            }
            if (color.r > 1) color.r = 1;
            if (color.g > 1) color.g = 1;
            if (color.b > 1) color.b = 1;
        }
        return {obj: obj, color: color}
    }

    this.traceScene = function () {
        var pov = new Vector(0,0,-4);
        var ray = new Ray();

        ray.origin = pov
        for (var x = 0; x < screen_width; x++) {
            for (var y = 0; y < screen_height; y++) {
                ray.direction.set((x-screen_width/2)/100,
                                  (y-screen_height/2)/100,
                                  4);
                ray.direction.normalize();
                var trace = this.traceRay(ray);
                var offset = x*4+y*4*screen_width;

                pixels.data[offset+3] = 255;
                pixels.data[offset+0] = trace.color.r*255;
                pixels.data[offset+1] = trace.color.g*255;
                pixels.data[offset+2] = trace.color.b*255;
            }
        }
    }
}

init();

</script>
</body>
</html>
